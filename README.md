Протоколы в swift -- инкапсулируют сущности их реализующие.

Протоколы позволяют скрыть конкретную реализацию сущности. Сущность получившая при инициализации тип протокола или переданная в метод как переметр типа протокола может предоставлять только функциональность описанную в этом протоколе. Протоколы позволяют декларативно описывать функциональность через их название и список инструментов, которые они предоставляют. Это упрощает понимание разработчком кодовой базы системы. Объявление сущности(например сервиса) через протокол позволяет не зависет от конкретной реализации(DI из солид. «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»). На протоколах строится паттерн "Делегат". 

С помощью протоколов можно сгруппировать функционал сервиса(например) по контексту. Для сервиса, поделенного на части через протоколы легче писать моки(в моке нужно реализовывать функционал не всего класса, но только описанный в протоколе)

DI -- Framework строит зависимости между компонентами программы в момент запроса компонента из DI-контейнера. DI -- Framework обязуется что за каждой абстракцией будет стоят конкретная реализация(при этом ничего о конкретной реализации компонент, который содержит данную абстракцию, знать не должен).

Виды DI
Initializer-based Dependency Injection
by passing the dependencies as parameters to the init functions and then storing them as member variables of your classes. 

Инъекция через инициализатор не всегда самый удобный способ. Например если View-компонент создан в Storyboard или в XIB, то init-метод для него не будет вызываться в коде явным образом.

Property-based Dependency Injection 
Инъекция зависимостей после инициализации. В таком случае свойства должны быть не приватными


UserDefault -- key-value хранилище. Предназначенно для сохрание начальных конфигурационных параметров приложения(поэтому так называется). В UserDefaults можно сохранять любой тип данных реализующий Codable протокол. Данные, сохраненные в UserDefaults не шифруются.     

Keychain -- key-value хранилище. Предназначен для небольших объемов данных, которые необходимо хранить в зашифрованном виде(например ключи, пароли и т.п.). Данные в keychain  сохраняются даже тогда, когда пользователь удаляет приложение. 

GCD -- это библиотека от Apple, написанная на языке С и С++.  Предоставляет верхнеуровневый интерфейс для работы с многопотоностью в OS Darwin.

DispatchWorkItem -- блок кода, который можно добавить в очередь(DispatchQueue). Может быть представлен в виде сущности класса или в виде замыкания. Как сущность класса предоставляет интерфейсы управления. 

Задачи можно группировать в группы, структурированные в виде очередей -- DispatchQueue.

При создании очереди задается тип выполнения задач в ней( serial или concurrent ).

Serial выполнение гарантирует что задачи будут выполняться строго по порядку их добавления в очередь, без переключения контектса. В одном потоке.

Concurrent выполнение гарантирует что задачи будут начинать свое выполнение по порядку их добавления в очередь, с переключением контекста. Порядок завершения задач не определен. Возможно выполнение одной очереди в разных потоках.

Все системные очереди кроме Main -- concurrent

Системные очереди(по qos): Main; UserInteractive; UserInitiated; default(global); utility; background

В момент запуска очереди программист указывает как она будет возвращать управление текущему потоку.

sync -- управление текущему потоку будет возвращенно только после завершения выполнения задач в очереди. 

async -- управление текущему потоку возвращается немедленно после запуска очереди. 

Проблемы многопоточности: race condition; priority inversion; deadlock

Thread Safe-код может быть безопасно вызван из разных потоков. Дополнительного разграничения одновременного доступа к нему не требуется.  

Context Switch -- переключение контекста(но не обязательно потока)	